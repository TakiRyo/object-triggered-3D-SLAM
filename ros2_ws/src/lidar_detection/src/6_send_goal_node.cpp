/*
 * Node Name: GoalSender
 * Role: Mission Planner / Sequencer
 * Logic:
 * 1. Subscribes to "/object_visiting_points" (Markers from Tracker).
 * 2. Finds the nearest unvisited point.
 * 3. Sends it to SystemManager (/manager/target_pose) continuously until reached.
 * 4. Manages "Visited" status locally.
 */

#include <rclcpp/rclcpp.hpp>
#include <visualization_msgs/msg/marker_array.hpp>
#include <geometry_msgs/msg/pose_stamped.hpp>
#include <nav_msgs/msg/odometry.hpp>
#include <cmath>
#include <vector>
#include <set>
#include <limits>
#include <algorithm>

struct TargetPoint {
    int unique_id;   // Marker ID (ObjID * 10 + index)
    int object_id;   // Parent Object ID (extracted from unique_id)
    float x, y;
};

class GoalSender : public rclcpp::Node
{
public:
  GoalSender() : Node("goal_sender")
  {
    // --- Parameters ---
    // The robot is considered "arrived" if within this distance.
    // Must be larger than Nav2 tolerance (e.g. 0.6 > 0.5)
    this->declare_parameter("reach_threshold", 0.60);
    reach_threshold_ = this->get_parameter("reach_threshold").as_double();

    // --- Subscribers ---
    // Listen for the visiting points generated by ObjectTracker
    points_sub_ = this->create_subscription<visualization_msgs::msg::MarkerArray>(
      "/object_visiting_points", 10, 
      std::bind(&GoalSender::pointsCallback, this, std::placeholders::_1));

    odom_sub_ = this->create_subscription<nav_msgs::msg::Odometry>(
      "/odom", 10, std::bind(&GoalSender::odomCallback, this, std::placeholders::_1));
    
    // --- Publishers ---
    goal_pub_ = this->create_publisher<geometry_msgs::msg::PoseStamped>("/manager/target_pose", 10);
    
    // Visualize which points are Active (Red), Pending (Grey), Visited (Green)
    status_pub_ = this->create_publisher<visualization_msgs::msg::MarkerArray>("/goal_status", 10);

    RCLCPP_INFO(this->get_logger(), "‚úÖ GoalSender Ready (Passive Mode). Waiting for points...");
  }

private:
  void odomCallback(const nav_msgs::msg::Odometry::SharedPtr msg) {
    robot_x_ = msg->pose.pose.position.x;
    robot_y_ = msg->pose.pose.position.y;
  }

  void pointsCallback(const visualization_msgs::msg::MarkerArray::SharedPtr msg)
  {
    std::vector<TargetPoint> available_targets;

    // 1. Parse incoming markers into our struct
    for (const auto &m : msg->markers) {
        // Only care about ADD actions
        if (m.action != visualization_msgs::msg::Marker::ADD) continue;
        
        TargetPoint p;
        p.unique_id = m.id;
        p.object_id = m.id / 10; // Decode Parent ID (e.g., 42 -> Object 4)
        p.x = m.pose.position.x;
        p.y = m.pose.position.y;
        
        // Only consider if NOT visited
        if (visited_ids_.find(p.unique_id) == visited_ids_.end()) {
            available_targets.push_back(p);
        }
    }

    // 2. Check if we reached the CURRENT ACTIVE target
    if (active_target_id_ != -1) {
        // Check distance to our stored active point
        float dist = std::hypot(robot_x_ - active_point_.x, robot_y_ - active_point_.y);
        
        // Check arrival
        if (dist < reach_threshold_) {
            RCLCPP_INFO(this->get_logger(), "üìç Reached Point ID %d (Obj %d)", active_target_id_, active_target_id_/10);
            visited_ids_.insert(active_target_id_);
            active_target_id_ = -1;     // Reset active target
            // current_object_focus_ = -1; // Optional: Keep focus to finish object
        }
    }

    // 3. Select NEXT Target (if idle)
    if (active_target_id_ == -1 && !available_targets.empty()) {
        
        TargetPoint* best_p = nullptr;
        float min_dist = std::numeric_limits<float>::max();

        // A. Priority Search: Try to finish current object first
        if (current_object_focus_ != -1) {
            for (auto &t : available_targets) {
                if (t.object_id == current_object_focus_) {
                    float d = std::hypot(robot_x_ - t.x, robot_y_ - t.y);
                    if (d < min_dist) { min_dist = d; best_p = &t; }
                }
            }
        }

        // B. Global Search: If no point found for current object (or no focus)
        if (best_p == nullptr) {
            min_dist = std::numeric_limits<float>::max(); // Reset min_dist
            for (auto &t : available_targets) {
                float d = std::hypot(robot_x_ - t.x, robot_y_ - t.y);
                if (d < min_dist) { min_dist = d; best_p = &t; }
            }
        }

        // C. Lock onto Goal
        if (best_p) {
            active_target_id_ = best_p->unique_id;
            current_object_focus_ = best_p->object_id;
            active_point_ = *best_p; // ‚òÖ Save the point data so we can publish it repeatedly
            
            RCLCPP_INFO(this->get_logger(), "üîí New Target Selected: Point %d (Obj %d)", active_target_id_, current_object_focus_);
        }
    }

    // 4. Publish Goal (CONTINUOUSLY)
    // As long as we have a target, we broadcast it.
    if (active_target_id_ != -1) {
        publishGoal(&active_point_);
    }
    
    // 5. Visualize Status (Green = Visited, Red = Active, Grey = Pending)
    publishStatusMarkers(msg);
  }

  void publishGoal(TargetPoint* p) {
      geometry_msgs::msg::PoseStamped goal;
      goal.header.frame_id = "map";
      goal.header.stamp = this->get_clock()->now();
      goal.pose.position.x = p->x;
      goal.pose.position.y = p->y;
      
      // Send Object ID in Z field so SystemManager knows when to Unfreeze
      goal.pose.position.z = (double)p->object_id; 

      // Orientation: Just send identity.
      goal.pose.orientation.w = 1.0; 

      goal_pub_->publish(goal);
  }

  void publishStatusMarkers(const visualization_msgs::msg::MarkerArray::SharedPtr input_msg) {
      visualization_msgs::msg::MarkerArray status_array;
      for (const auto &m : input_msg->markers) {
          visualization_msgs::msg::Marker s = m;
          s.ns = "status";
          s.action = visualization_msgs::msg::Marker::ADD;
          s.scale.x = 0.2; s.scale.y = 0.2; s.scale.z = 0.2; // Slightly larger for visibility
          
          if (visited_ids_.count(s.id)) {
              s.color.r = 0.0; s.color.g = 1.0; s.color.b = 0.0; s.color.a = 1.0; // Green = Visited
          } else if (s.id == active_target_id_) {
              s.color.r = 1.0; s.color.g = 0.0; s.color.b = 0.0; s.color.a = 1.0; // Red = Active
          } else {
              s.color.r = 0.5; s.color.g = 0.5; s.color.b = 0.5; s.color.a = 0.5; // Grey = Pending
          }
          status_array.markers.push_back(s);
      }
      status_pub_->publish(status_array);
  }

  rclcpp::Subscription<visualization_msgs::msg::MarkerArray>::SharedPtr points_sub_;
  rclcpp::Subscription<nav_msgs::msg::Odometry>::SharedPtr odom_sub_;
  rclcpp::Publisher<geometry_msgs::msg::PoseStamped>::SharedPtr goal_pub_;
  rclcpp::Publisher<visualization_msgs::msg::MarkerArray>::SharedPtr status_pub_;

  double robot_x_ = 0.0, robot_y_ = 0.0;
  double reach_threshold_;
  
  std::set<int> visited_ids_;
  int active_target_id_ = -1;
  int current_object_focus_ = -1;
  
  TargetPoint active_point_; // ‚òÖ Member variable to store current goal
};

int main(int argc, char **argv)
{
  rclcpp::init(argc, argv);
  rclcpp::spin(std::make_shared<GoalSender>());
  rclcpp::shutdown();
  return 0;
}